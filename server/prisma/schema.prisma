generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NOVO ENUM - garante type-safety no banco
enum RecurrenceInterval {
  semanal
  mensal
  trimestral
  semestral
  anual
}

model User {
  id            String         @id @default(uuid())
  email         String         @unique
  password      String
  displayName   String?        @map("display_name")
  chatId        String?        @unique @map("chat_id")
  chatUsername  String?        @map("chat_username")
  subscription  String         @default("none")        // 'none' | 'basic' | 'pro'
  report        String         @default("none")        // 'none' | 'simple' | 'advanced'
  lastReport    DateTime?      @map("last_report")
  notifyEmail       Boolean   @default(true)  @map("notify_email")
  notifyChat        Boolean   @default(true)  @map("notify_chat")
  notifyDashboard   Boolean   @default(true)  @map("notify_dashboard")
  createdAt     DateTime       @default(now()) @map("created_at")
  updatedAt     DateTime       @updatedAt @map("updated_at")

  // Gamification fields
  level               Int       @default(1)
  experience          Int       @default(0)
  totalGoalsCompleted Int       @default(0) @map("total_goals_completed")
  currentStreak       Int       @default(0) @map("current_streak")
  longestStreak       Int       @default(0) @map("longest_streak")

  financeRecords      FinanceRecord[]
  aiAlerts            AiAlert[]
  financialGoals      FinancialGoal[]
  badges              UserBadge[]
  customCategories    UserCustomCategory[]
  passwordResetTokens PasswordResetToken[]
  reports             Report[]

  @@map("users")
}

model PasswordResetToken {
  id        String    @id @default(uuid())
  userId    String    @map("user_id")
  tokenHash String    @unique @map("token_hash")
  expiresAt DateTime  @map("expires_at")
  usedAt    DateTime? @map("used_at")
  createdAt DateTime  @default(now()) @map("created_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("password_reset_tokens")
}

model Report {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  status          String    // 'pending' | 'generating' | 'sent' | 'failed' | 'insufficient_data'
  type            String    // 'simple' | 'advanced' (copiado de User.report no momento da criação)
  content         String?   @db.Text
  requestedAt     DateTime  @default(now()) @map("requested_at")
  generatedAt     DateTime? @map("generated_at")
  sentAt          DateTime? @map("sent_at")
  countsForLimit  Boolean   @default(true) @map("counts_for_limit")
  errorMessage    String?   @map("error_message")
  filterStartDate String?   @map("filter_start_date")
  filterEndDate   String?   @map("filter_end_date")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, requestedAt(sort: Desc)])
  @@index([userId, countsForLimit, requestedAt])
  @@index([userId, status])
  @@map("reports")
}

model FinanceRecord {
  id              String   @id @default(uuid())
  userId          String   @map("user_id")
  valor           Decimal  @db.Decimal(12, 2)
  de              String?
  para            String?
  tipo            String   // 'entrada' | 'saida'
  categoria       String
  classificacao   String?  // 'fixo' | 'variavel' | 'recorrente'
  dataComprovante DateTime @map("data_comprovante") @db.Date
  createdAt       DateTime @default(now()) @map("created_at")

  // ⚠️ IMPORTANTE: isFuture é derivado de dataComprovante > hoje
  // Sempre recalcular antes de usar em queries críticas
  isFuture           Boolean             @default(false) @map("is_future")
  recurrenceGroupId  String?             @db.Uuid @map("recurrence_group_id") // UUID explícito
  recurrenceInterval RecurrenceInterval? @map("recurrence_interval")          // ENUM, não String
  isInfinite         Boolean             @default(false) @map("is_infinite")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Índices compostos para queries comuns
  @@index([userId, dataComprovante(sort: Desc)]) // Query principal: buscar por usuário + ordenar por data
  @@index([userId, tipo, dataComprovante]) // Filtro por tipo + data
  @@index([userId, categoria]) // Filtro por categoria
  @@index([userId, recurrenceGroupId]) // Query por grupo de recorrência
  @@index([userId, isFuture]) // Query de registros futuros
  @@map("finance_records")
}

model AiAlert {
  id            String   @id @default(uuid())
  userId        String   @map("user_id")
  aviso         String
  justificativa String?
  prioridade    String   // 'baixa' | 'media' | 'alta'
  context       String   @default("dashboard") // 'dashboard' | 'goals' | 'both'
  status        String?  // null | 'concluido' | 'ignorado'
  createdAt     DateTime @default(now()) @map("created_at")
  updatedAt     DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Índices compostos para queries comuns
  @@index([userId, prioridade, createdAt(sort: Desc)]) // Buscar alertas por usuário + prioridade + data
  @@index([userId, status]) // Filtrar alertas por status
  @@map("ai_alerts")
}

model FinancialGoal {
  id              String    @id @default(uuid())
  userId          String    @map("user_id")
  title           String
  description     String?
  type            String    // 'economia' | 'limite_gasto' | 'meta_receita' | 'investimento'
  targetValue     Decimal   @map("target_value") @db.Decimal(12, 2)
  currentValue    Decimal   @default(0) @map("current_value") @db.Decimal(12, 2)
  category        String?   // Liga com FinanceRecord.categoria
  period          String?   // 'mensal' | 'trimestral' | 'anual' | 'personalizado'
  startDate       DateTime  @map("start_date") @db.Date
  endDate         DateTime  @map("end_date") @db.Date
  status          String    @default("ativo") // 'ativo' | 'pausado' | 'concluido' | 'falhou'
  autoComplete    Boolean   @default(true) @map("auto_complete")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")
  completedAt     DateTime? @map("completed_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Índices compostos para queries comuns
  @@index([userId, status, endDate]) // Buscar metas ativas por usuário + ordenar por data fim
  @@index([userId, type, status]) // Filtro por tipo de meta + status
  @@map("financial_goals")
}

model Badge {
  id          String      @id @default(uuid())
  code        String      @unique
  name        String
  description String
  icon        String
  category    String      // 'metas' | 'consistencia' | 'economia' | 'especial'
  createdAt   DateTime    @default(now()) @map("created_at")

  users       UserBadge[]

  @@map("badges")
}

model UserBadge {
  id         String   @id @default(uuid())
  userId     String   @map("user_id")
  badgeId    String   @map("badge_id")
  unlockedAt DateTime @default(now()) @map("unlocked_at")

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  badge Badge @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  @@unique([userId, badgeId])
  @@index([userId])
  @@map("user_badges")
}

model UserCustomCategory {
  id        String   @id @default(uuid())
  userId    String   @map("user_id")
  name      String
  tipo      String   // 'entrada' | 'saida'
  createdAt DateTime @default(now()) @map("created_at")
  updatedAt DateTime @updatedAt @map("updated_at")

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, name])
  @@index([userId])
  @@map("user_custom_categories")
}
